@page "/Day05"
@page "/Day5"
@inject DataFetcher dataFetcher

<PageTitle>AoC 2025 - Day @dayNumber</PageTitle>

<ChallengeContainer DayNumber=@dayNumber 
                    @bind-ChallengeInput=@inputData
                    @bind-TestInput=@testData
                    SolveChallenge1=@SolveChallenge1
                    SolveChallenge2=@SolveChallenge2
                    Challenge1Result=@challenge1Result.ToString()
                    Challenge2Result=@challenge2Result.ToString()
/>

@code {
    private readonly int dayNumber = 5;
    string inputData = string.Empty;
    string testData = string.Empty;
    private int? challenge1Result = null;
    private long? challenge2Result = null;

    private async Task LoadData()
    {
        inputData = await dataFetcher.FetchDataAsync(dayNumber);
        testData = TestData.Day5;
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }

    private int Challenge1Solution(string input)
    {
        int accumulator = 0;

        // Parse string into an array of strings, each string is a line of the input
        string[] parsedInputData = inputData.Split("\n");
        List<(long lowerBound, long upperBound)> freshRanges = [];
        List<long> productIds = [];

        foreach (string line in parsedInputData)
        {
            if (line.Contains("-"))
            {
                string[] parts = line.Split("-");
                long lowerBound = long.Parse(parts[0]);
                long upperBound = long.Parse(parts[1]);
                freshRanges.Add((lowerBound, upperBound));
            }

            if (!line.Contains("-") && line.Trim() != string.Empty)
            {
                long productId = long.Parse(line.Trim());
                productIds.Add(productId);
            }
        }

        foreach (long productId in productIds)
        {
            foreach ((long lowerBound, long upperBound) in freshRanges)
            {
                if (productId >= lowerBound && productId <= upperBound)
                {
                    accumulator++;
                    break;
                }
            }
        }

        return accumulator;
    }

    private void SolveChallenge1()
    {
        if (inputData != string.Empty)
        {
            try
            {
                challenge1Result = Challenge1Solution(inputData);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }

    // Challenge 2
    private long Challenge2Solution(string input)
    {
        long accumulator = 0;

        // Parse string into an array of strings, each string is a line of the input
        string[] parsedInputData = inputData.Split("\n");
        List<(long lowerBound, long upperBound)> freshRanges = [];
        List<(long lowerBound, long upperBound)> deduplicatedFreshRanges = [];

        foreach (string line in parsedInputData)
        {
            if (line.Contains("-"))
            {
                string[] parts = line.Split("-");
                long lowerBound = long.Parse(parts[0]);
                long upperBound = long.Parse(parts[1]);
                freshRanges.Add((lowerBound, upperBound));
            }
        }

        // If no ranges, nothing to deduplicate
        if (freshRanges.Count == 0)
        {
            return accumulator;
        }

        // Sort ranges by lowerBound, then by upperBound
        freshRanges.Sort((a, b) =>
        {
            int cmp = a.lowerBound.CompareTo(b.lowerBound);
            if (cmp != 0) return cmp;
            return a.upperBound.CompareTo(b.upperBound);
        }); 

        // Merge overlapping ranges to ensure no overlaps in the result
        long currentLower = freshRanges[0].lowerBound;
        long currentUpper = freshRanges[0].upperBound;

        for (int i = 1; i < freshRanges.Count; i++)
        {
            var (l, u) = freshRanges[i];
            if (l <= currentUpper) // Overlaps or touches
            {
                // Extend current merged range
                if (u > currentUpper)
                {
                    currentUpper = u;
                }
            }
            else
            {
                // Close current range and start a new one
                deduplicatedFreshRanges.Add((currentLower, currentUpper));
                currentLower = l;
                currentUpper = u;
            }
        }

        // Add the final range
        deduplicatedFreshRanges.Add((currentLower, currentUpper));

        // Find the number of values in each de-duplicated range
        foreach ((long lowerBound, long upperBound) range in deduplicatedFreshRanges)
        {
            accumulator += ((range.upperBound - range.lowerBound) + 1);
        }

        // The accumulator can be used later based on deduplicatedFreshRanges
        return accumulator;
    }

    private void SolveChallenge2()
    {
        if (inputData != string.Empty)
        {
            try
            {
                challenge2Result = Challenge2Solution(inputData);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}
