@page "/Day04"
@page "/Day4"
@inject DataFetcher dataFetcher

<PageTitle>AoC 2025 - Day @dayNumber</PageTitle>

<ChallengeContainer DayNumber=@dayNumber
                    @bind-ChallengeInput=@inputData
                    @bind-TestInput=@testData
                    SolveChallenge1=@SolveChallenge1
                    SolveChallenge2=@SolveChallenge2
                    Challenge1Result=@challenge1Result.ToString()
                    Challenge2Result=@challenge2Result.ToString() />

@code {
    private readonly int dayNumber = 4;
    string inputData = string.Empty;
    string testData = string.Empty;
    private int? challenge1Result = null;
    private int? challenge2Result = null;

    private async Task LoadData()
    {
        inputData = await dataFetcher.FetchDataAsync(dayNumber);
        testData = TestData.Day4;
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }

    private int Challenge1Solution(string input)
    {
        int accumulator = 0;

        // Parse string into an array of strings, each string is a line of the input
        string[] parsedInputData = inputData.Split("\n", StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        // Parse lines into a 2D character array
        if (parsedInputData.Length == 0)
        {
            return accumulator;
        }

        int rows = parsedInputData.Length;
        int cols = parsedInputData[0].Length;

        char[,] wrappingPaperRolls = new char[rows, cols];

        for (int i = 0; i < rows; i++)
        {
            // Optionally ensure all lines have consistent length; if not, throw or handle
            if (parsedInputData[i].Length != cols)
            {
                throw new InvalidOperationException("Input lines have inconsistent lengths.");
            }

            for (int j = 0; j < cols; j++)
            {
                wrappingPaperRolls[i, j] = parsedInputData[i][j];
            }
        }

        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                if (wrappingPaperRolls[i, j] == '@')
                {
                    int adjacentRolls = 0;

                    // Check the cells around the target cell to count how many '@' exist in the surrounding cells

                    // [i - 1, j - 1]
                    if (i - 1 >= 0 && j - 1 >= 0 && wrappingPaperRolls[i - 1, j - 1] == '@')
                    {
                        adjacentRolls++;
                    }

                    // [i - 1, j]
                    if (i - 1 >= 0 && wrappingPaperRolls[i - 1, j] == '@')
                    {
                        adjacentRolls++;
                    }

                    // [i - 1, j + 1]
                    if (i - 1 >= 0 && j + 1 < cols && wrappingPaperRolls[i - 1, j + 1] == '@')
                    {
                        adjacentRolls++;
                    }

                    // [i, j - 1]
                    if (j - 1 >= 0 && wrappingPaperRolls[i, j - 1] == '@')
                    {
                        adjacentRolls++;
                    }

                    // [i, j + 1]
                    if (j + 1 < cols && wrappingPaperRolls[i, j + 1] == '@')
                    {
                        adjacentRolls++;
                    }

                    // [i + 1, j - 1]
                    if (i + 1 < rows && j - 1 >= 0 && wrappingPaperRolls[i + 1, j - 1] == '@')
                    {
                        adjacentRolls++;
                    }

                    // [i + 1, j]
                    if (i + 1 < rows && wrappingPaperRolls[i + 1, j] == '@')
                    {
                        adjacentRolls++;
                    }

                    // [i + 1, j + 1]
                    if (i + 1 < rows && j + 1 < cols && wrappingPaperRolls[i + 1, j + 1] == '@')
                    {
                        adjacentRolls++;
                    }

                    if (adjacentRolls < 4)
                    {
                        accumulator++;
                    }
                }
            }
        }

        return accumulator;
    }

    private void SolveChallenge1()
    {
        if (inputData != string.Empty)
        {
            try
            {
                challenge1Result = Challenge1Solution(inputData);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }

    // Challenge 2
    private int Challenge2Solution(string input)
    {
        int accumulator = 0;

        // Parse string into an array of strings, each string is a line of the input
        string[] parsedInputData = inputData.Split("\n", StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        // Parse lines into a 2D character array
        if (parsedInputData.Length == 0)
        {
            return accumulator;
        }

        int rows = parsedInputData.Length;
        int cols = parsedInputData[0].Length;

        char[,] wrappingPaperRolls = new char[rows, cols];

        for (int i = 0; i < rows; i++)
        {
            // Optionally ensure all lines have consistent length; if not, throw or handle
            if (parsedInputData[i].Length != cols)
            {
                throw new InvalidOperationException("Input lines have inconsistent lengths.");
            }

            for (int j = 0; j < cols; j++)
            {
                wrappingPaperRolls[i, j] = parsedInputData[i][j];
            }
        }

        int? clearedThisTime = null;

        while (clearedThisTime != 0)
        {
            clearedThisTime = 0;

            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    if (wrappingPaperRolls[i, j] == '@')
                    {
                        int adjacentRolls = 0;

                        // Check the cells around the target cell to count how many '@' exist in the surrounding cells

                        // [i - 1, j - 1]
                        if (i - 1 >= 0 && j - 1 >= 0 && wrappingPaperRolls[i - 1, j - 1] == '@')
                        {
                            adjacentRolls++;
                        }

                        // [i - 1, j]
                        if (i - 1 >= 0 && wrappingPaperRolls[i - 1, j] == '@')
                        {
                            adjacentRolls++;
                        }

                        // [i - 1, j + 1]
                        if (i - 1 >= 0 && j + 1 < cols && wrappingPaperRolls[i - 1, j + 1] == '@')
                        {
                            adjacentRolls++;
                        }

                        // [i, j - 1]
                        if (j - 1 >= 0 && wrappingPaperRolls[i, j - 1] == '@')
                        {
                            adjacentRolls++;
                        }

                        // [i, j + 1]
                        if (j + 1 < cols && wrappingPaperRolls[i, j + 1] == '@')
                        {
                            adjacentRolls++;
                        }

                        // [i + 1, j - 1]
                        if (i + 1 < rows && j - 1 >= 0 && wrappingPaperRolls[i + 1, j - 1] == '@')
                        {
                            adjacentRolls++;
                        }

                        // [i + 1, j]
                        if (i + 1 < rows && wrappingPaperRolls[i + 1, j] == '@')
                        {
                            adjacentRolls++;
                        }

                        // [i + 1, j + 1]
                        if (i + 1 < rows && j + 1 < cols && wrappingPaperRolls[i + 1, j + 1] == '@')
                        {
                            adjacentRolls++;
                        }

                        if (adjacentRolls < 4)
                        {
                            wrappingPaperRolls[i, j] = 'X';
                            clearedThisTime++;
                            accumulator++;
                        }
                    }
                }
            }
        }

        return accumulator;
    }

    private void SolveChallenge2()
    {
        if (inputData != string.Empty)
        {
            try
            {
                challenge2Result = Challenge2Solution(inputData);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}
